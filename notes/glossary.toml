title = Glossary

[Programming]
  "Abstract Syntax Trees" = """
    ASTs are simplified syntactic representations of source
    code, and they are most often expressed by the data structures of the
    language used for implementation.
    """

  "Context-free grammar" = """
    In formal language theory, a context-free grammar (CFG) is a formal
    grammar in which every production rule is of the form:

    A   →   α

    where A is a single nonterminal symbol, and α is a string of terminals
    and/or nonterminals.
    """

  "Concrete Syntax Trees" = """
    (CST) or also know as (Parse Trees) are a representation of grammars in a
    tree-like form.
    """

  "Esoteric Programming Language" = """
    Esolongs are programming languages designed to test the boundaries of
    computer pgramming language design often as a proof of concept, art, or
    hacking interface to another language.
    """

  "Extended Backus-Naur Formt" = """
    EBNF is a family of metasyntax notations, any of which can be used to
    express context-free grammar.
    """

  "Greenspun's tenth rule" = """
    Any sufficiently complicated C or Fortran program contains an ad hoc,
    informally-specified, bug-ridden, slow implementation of half of Common
    Lisp.
    """

  "Higher Order Functions" =  """
    HOF are functions that do one of two things:

    1. Takes one or more functions are arguments
    2. Returns a function as a result
    """

  S-expressions = """
    A notation for nested list (tree-structured) data invented
    for and popularized for Lisp.
    """

  "Single Abstract Method" = """
    (SAM) - These are interfaces which have exactly one
    abstract method. These are also known as functional interfaces.
    
    For example, in Scala this allows you do have a trait like so:

    ```scala
    trait MyTrait {
      def a(m: String): Unit
    }
    ```
    
    And instead of using the standard syntax you can use the SAM syntax:

    ```scala
    val x: MyTrait = (m: String) => println(m)
    ```
    """

  "Twelve-Factor App Methodology" = """
    1. Codebase: One codebase tracked in revision control, many deploys.
    2. Dependencies: Explicitly declare and isolate dependencies.
    3. Config: Store config in the environment.
    4. Backing services: Treat backing services as attached resources.
    5. Build, release, run: Strictly separate build and run stages.
    6. Processes: Execute the app as one or more stateless processes.
    7. Port binding: Export services via port binding.
    8. Concurrency: Scale out via the process model.
    9. Disposability: Maximize robustness with fast startup and graceful shutdown.
    10. Dev/prod parity: Keep development, staging, and production as similar as possible.
    11. Logs: Treat logs as event streams.
    12. Admin processes: Run admin/management tasks as one-off processes.

    - Taken from https://12factor.net
    """
